\chapter{Methodology}
\label{chap:methodology}

This chapter describes the methodology used to compare and rank the studied cross-platform tools. The methodology follows the suggested 6-step approach presented in \cite{Jadhav:2011} (see chapter \ref{sec:sw-selection}). The six steps are:

\begin{enumerate}
    \item Define selection criteria
    \item Identify potential candidates
    \item List selected alternatives
    \item Define evaluation criteria
    \item Evaluate selected alternatives
    \item Select the most suitable alternative
\end{enumerate}

Every step will be further expanded in the following sections.

\section{Define selection criteria}
\label{sec:selection-criteria}

In this first step, the selection criteria for the tool are recorded. These requirements will be used later (in step 3) to filter a list of potential candidates. 

As the research presented in this thesis is conducted on behalf of CapGemini, the selection criteria are determined by their consultants and were recorded during the kick-off meeting on October 15, 2012. In order to qualify as a viable cross-platform tools, it has to meet the following requirements:

\begin{itemize}
    \item \textbf{It \emph{must} produce ``native'' Android \emph{and} iOS applications.} CapGemini focusses mainly on Android and iOS because their clients mainly focus on these platforms. Support for other platforms is desirable but not not a necessity.
    \item \textbf{It \emph{must} be able to produce \emph{both} tablet and smartphone applications, preferably from the same codebase.} Some clients want tablet applications, some clients want smartphone apps, some clients want both.
\end{itemize}

This list of essential requirements is extended with additional requirements. These are not essential as they can be circumvented in some way though they will generally result in higher productivity.
    
\begin{itemize}    
    \item \textbf{It \emph{should} be usable to create enterprise applications with.} CapGemini specializes in the development of data-driven enterprise applications. Such applications usually contain a lot of forms and don't require high performance graphics (like for instance in 3D games). Even though it is possible to develop an enterprise application on top of a 3D engine, it will probably not result in good productivity.
    \item \textbf{It \emph{should} have a certain degree of maturity} Ideally, the tool should be maintained for as long applications are created with it (and maintained). 
    \item \textbf{It \emph{should} have good support, provided by either the vendor or by the community.} In case of a problem, there should be a way to get support.
\end{itemize}

\section{Identify potential candidates}

In this stage, the evaluator tries to identify as much potential candidates as possible. These candidates do not necessarily have to meet the requirements from the previous stage as this is merely a discovery phase. The result of this stage will be a list of potential candidates.

Discovery of cross-platform tools has already been done extensively by VisionMobile. The latest cross-platform tools report \cite{VMCPT:2012} contains a list of 100 cross-platform tools they tracked as part of their research. Because additional internet searches did not reveal new tools, this list is used as output of this stage.

\section{List selected alternatives}

In this phase, the candidates obtained from the previous stage are filtered with the selection criteria from the first stage. The result of this stage is a list of alternatives worth investigating.

The list of tools from the previous stage contains a plethora of tools. Using the requirements from stage 1, a large number of tools can be left out:

\begin{itemize}
    \item tools that do not produce native applications for Android and iOS;
    \item tools that do not produce tablet and smartphone applications;
    \item special-purpose tools that are not well suited for the intended use, e.g. specialized 3D engines;
    \item tools with an uncertain future, e.g. Flash-based systems or cutting-edge tools;
    \item tools that do not offer good support. 
\end{itemize}

From 100 potential candidates, 7 tools listed in \tref{table:tools} were selected.

\begin{table}[h!]
    \begin{center}
        \begin{tabular}{lcc}
            \hline
            Name & Architecture & Type \\
            \hline 
            Apache Cordova & Hybrid & Open Source \\
            Appcelerator Titanium & Interpreted & Open Source \\
            Motorola Rhodes & Interpreted & Open Source \\
            Trigger.io & Hybrid & Commercial \\
            MoSync & Cross-Compiled + Hybrid & Open Source \\
            Kony & Hybrid & Commercial \\
            Xamarin & Cross-compiled & Commercial \\
            \hline
        \end{tabular}
        \caption{The remaining tools after application of the selection criteria.}
        \label{table:tools}
    \end{center}
\end{table}

This thesis will compare two of these tools with each other and  with the native development kits for both Android and iOS. The selected tools are Apache Cordova (formerly known as PhoneGap) and Motorola Rhodes. 

Apache Cordova was chosen because of its popularity among developers and Motorola Rhodes was chosen because it focusses on enterprise applications. 

Appcelerator Titanium and Xamarin were not selected because they are evaluated by another student with the same research topic. 

Trigger.io was not selected because it was too similar to Apache Cordova at first sight: same architecture, same languages, \ldots

\TODO{From what I read now, I should have selected MoSync, why didn't I? Don't really have a reason for it except maybe that I didn't research it quite well. Was also not prioritized by CapGemini but might have been my influence...}

Kony --- even though apparently using the the same architecture as Apache Cordova --- targets enterprise applications, which made it a very good rival for Motorola Rhodes. However, there was no free trial available for Kony, which resulted in the selection of Motorola Rhodes.

Apache Cordova and Motorola Rhodes are discussed in more detail in chapter \ref{chap:tools}.

\section{Define evaluation criteria}

This is probably the most important of all stages. Setting up good grounds for comparison is paramount. The criteria are therefore carefully extracted from interviews with CapGemini employees and literature.

\subsection{Interviews with Capgemini employees}
\label{sec:interviews}

A finished application is the result of a cooperation of different people with various roles. Every person experiences mobile application development in another way. In order to gain a better understanding of these experiences, three interviews with CapGemini employees were planned: one interview with a developer, one interview with a mobile architect and one interview with a sales representative. 

The goal of these interviews is to reveal important criteria that should be considered during the evaluation of the cross-platform tools. The following sections present a summary of these interviews.

\subsubsection{Developer}

Developers are responsible for the development of the application. They can provide valuable insights into the typical technical issues that are encountered when developing a mobile application.

\paragraph{Development environment}

One of the relevant topics for application developers is the development environment since they will spend most of their time in it. Typically, the development environment is built on top of a Windows operating system and the Eclipse\footnote{\url{http://eclipse.org}} IDE. This IDE is preferred because it is fast, efficient and highly customizable, which are desirable qualities for a good IDE. Also, most of the documentation is explicitly written for Eclipse. 

\paragraph{Development cycle}

Development happens locally and changes are deployed in an \emph{unstable}  environment. When features are ready to be tested, they are promoted and pushed to a \emph{staging} environment, where they will be tested by for instance a number of end users. When the features are tested and ready to ship, a new production release is planned. In case mobile devices are involved, the application is tested on the device as much as possible.

The code is also checked overnight on a continuous integration server, which runs all unit tests together with a number of other useful tools like FindBugs\footnote{FindBugs uses static analysis to find common bugs, \url{http://findbugs.sourceforge.net}.}. Every morning, a detailed report of the state of the code is generated.

\paragraph{Requirements for cross-platform tools}

The requirements for cross-platform tools are that it (1) should work properly, (2) should not be too complex, (3) has at least decent performance (preferred over ease of use) and (4) that it is customizable graphically. Most clients have specific styling requirements.

\paragraph{Attitude towards new languages and tools} 

Learning new tools and languages is not considered problematic as long as it is worth investing in and/or requested by clients. Typically, one or more developers familiarize themselves with the tool/language and teach the other developers during a training session. Also, Capgemini has good partnerships to fall back on in case of a problem. 

\subsubsection{Mobile architect}

The architect is responsible for the overall design of the application and makes the important decisions regarding used technology. Therefore, this person is best suited to describe the typical application structure and the trade-offs that have to be made constantly.

\paragraph{Focal points in mobile architectures} 

Mobile architectures consist mainly of two major components: a front-end component and a back-end component. On the side of the front-end (the mobile application), the most important factor is the degree of integration with the device.

On the side of the back-end, the most important factors are the services the application needs to integrate with. An additional server, called the \emph{mobile orchestrator} or \emph{mobile hub}, will handle this integration and expose it in a single interface to the mobile application. This protects the back-end from the increased number of requests and allows for caching and other integrations like targeted advertisement campaigns.

\paragraph{Requirements for cross-platform tools}

There are a number of requirements for cross-platform tools:
\begin{itemize}
    \item \textbf{Adoption} How many developers are using this tool? The number of users is mostly a good measure for the quality of the tool. A large user base is also beneficial when facing problems because it is more likely to get answers.
    \item \textbf{Future proof} Will the tool survive? Is there enough financial backing or community effort? It is not very wise to start a project that relies on a tool that has an unclear future. 
    \item \textbf{Documentation} Good documentation is priceless as it can save numerous hours of digging through code. 
    \item \textbf{Support} In case of a problem, is there an official channel to open a ticket? This could be either paid support or good community support. Either way, it should solve the problem. Delay due to unsolvable problems is unacceptable.
    \item \textbf{Customizability} Clients have specific requirements with regard to user interfaces and the tool should make this possible. Also, can the tool be expanded with plugins? A plugin architecture can contribute substantially to the customizability of the tool.
    \item \textbf{Supported devices} Which devices and runtimes does the tool support? In a B2B\footnote{Business-to-business, or commerce between businesses} context, devices are mostly controlled by an organization and the tool does not need to support many devices. In a B2C\footnote{Business-to-consumer, or commerce between a business and consumers} context on the other hand, the organization cannot control the devices and consequently, the tool should support a lot more devices. Does the tool cover most or all of the used devices in this case?
    \item \textbf{Performance} The benefits of cross-platform development must justify the costs in terms of performance. If it took virtually no time to develop the application but it is slow, the application is useless. 
    \item \textbf{Tools} Does this cross-platform tool allow to reuse the development tools that are already in use? Most people are more productive with the tools they are familiar with.
\end{itemize}

\paragraph{Usability} 

Usability is a big concern when developing cross-platform. Users are accustomed to the native look \& feel and wish to see new applications with similar styling. Even HTML5 applications are designed to mimic the native look \& feel of the device. It is therefore hard to write applications with a single code base, even though this is desirable. Only when the application has a custom user interface that is in no way related to the native look \& feel of the devices, the user interface can be reused across devices.

\subsubsection{Sales representative}

The sales representative records the client's requirements and sells the application. The salesman is therefore capable to describe the typical client requirements.

\paragraph{Application types}

Roughly speaking, there are two types of applications: consumer applications and business critical applications. The first type of application often involves a lot of marketing and branding, which is not Capgemini's core business. For this kind of applications, businesses usually consult a marketing agency that makes this kind of (rather short-lived) mobile applications.

Capgemini focusses on the second type of application. These applications mostly handle data and do not rely on device specific hardware like for instance GPS or NFC\footnote{Near Field Communication, a wireless technology based on RFID}. However, clients are becoming aware of these device features and are starting to request this kind of device integration. 

\paragraph{Customer requirements} 

When clients come to Capgemini with a problem that they would like to solve with a mobile application, they typically do not have special technical requirements. These requirements are most often formulated in other terms. One example is the choice for native versus cross-platform. It could happen that the client has not yet decided on which devices to use or that the client does not want to create a lock-in situation by choosing for a single vendor. In that case, the application clearly has to work cross-platform. Clients could also wish to use NFC technology, which rules out iOS as a platform. When there is no compelling reason to choose for either of both, Capgemini can help the client to make an appropriate decision. Performance is almost never a primary requirement. Perhaps this is implicitly assumed?

\subsubsection*{Summary of interviews}

\TODO{List of criteria resulting from interviews again?}

\subsection{Literature}

The criteria extracted from the interviews are complemented with criteria from literature. As mentioned before in the literature study, only criteria that are used for evaluating benefits are selected here. By separating costs and benefits, a reliable cost-benefit analysis can be made in the end. The evaluation criteria from literature originate from reports by VisionMobile and Gartner.

VisionMobile\footnote{VisionMobile is an ecosystems analyst firm, \url{http://www.visionmobile.com/}.} has conducted a worldwide survey about cross-platform tools. They received answers from over 2400 developers across 91 countries. The survey includes a question about the key reasons to select a particular tool and also includes a question about the key reasons to drop a cross-platform tool. The top 10 for both questions is summarized in \tref{tab:select} and \tref{tab:drop}.

\begin{table}[h]
    \begin{center}
        \begin{tabular}{clr}
            \hline
            Rank & Key reason to select tool & Share \\
            \hline
            1  & It supports the platforms I am targeting & 61\% \\
            2  & Allows me to use my existing skills & 43\% \\
            3  & Low cost or free & 40\% \\
            4  & Rapid development process & 33\% \\
            5  & Easy learning curve & 23\% \\
            6  & Rich UI capabilities & 19\% \\
            7  & Access to device or hardware APIs & 10\% \\
            8  & High Performance / low runtime overhead & 9\% \\
            9  & Well suited for games development & 8\% \\
            10 & Good vendor support and services & 8\% \\
            \hline
        \end{tabular}
        \caption{Top 10 reasons to select a particular cross-platform tool. Respondents could enter their top 3 and only the response for the tools that are selected by 50+ developers are counted, which is 1512 responses \cite{VMCPT:2012}.}
        \label{tab:select}
    \end{center}
\end{table}

\begin{table}[h]
    \begin{center}
        \begin{tabular}{clr}
            \hline
            Rank & Key reason to drop tool & Share \\
            \hline
            1  & Low performance / high runtime overhead & 29\% \\
            2  & Does not support the platforms I am targeting & 25\% \\
            3  & Steep learning curve & 24\% \\
            4  & Restricted UI capabilities & 22\% \\
            5  & Does not let me use my existing development skills & 22\% \\
            6  & High costs & 22\% \\
            7  & Slow development process & 21\% \\
            8  & Challenges with debugging & 18\% \\
            9  & Access to device or hardware APIs & 17\% \\
            10 & Uncertainty of vendor future or platform roadmap & 14\% \\
            \hline
        \end{tabular}
        \caption{Top 10 reasons to drop a particular cross-platform tool. Respondents could enter their top 3 and only the responses for the tools that were dropped by 50+ developers are counted, which is 1109 responses \cite{VMCPT:2012}.}
        \label{tab:drop}
    \end{center}
\end{table}

It is clear from \tref{tab:select} and \tref{tab:drop} that the key reasons for selecting a certain tool are more or less the same for dropping a tool. Common themes are (1) Platform support, (2) skill reuse, (3) development cost, (4) productivity or development time, (5) learning curve, (6) user interface capabilities, (7) device APIs and (8) performance. Non-common themes are (9) game development suitability, (10) vendor support, (11) tooling and testing and (12) concerns about the future of the tool.

From this list, (3), (4), (5) and (9) are omitted: (3) is clearly a cost, (4) is also a cost, albeit less clearly. However, developers need to be paid and consequently, development time is a cost. Capgemini does not develop games, which rules out (9). The interviews also revealed that typically somebody specializes in a certain tool or language and subsequently trains other developers and in case somebody gets stuck, there is almost always somebody to provide the necessary support. This should improve the learning curve and therefore eliminates (5) as an issue \TODO{Is this valid argumentation? :/}. 

Gartner has also done similar research in 2011 \cite{Gartner:CPT:2011}. The report of this research is not freely available but the criteria they identified are more or less clear from the table of contents. The criteria mostly overlap with the criteria from VisionMobile but also add (13) toolset reuse and (14) code reuse and organize them in three categories: portability, native experience and development experience.

\subsubsection*{Summary of literature}

\TODO{List the criteria from literature once more?}

\subsection*{Summary of evaluation criteria}

The identified criteria from the interviews and literature are combined into a single hierarchy of evaluation criteria. The criteria are organized in three categories, similar to the Gartner report.

\TODO{I think I need to explain more why exactly these criteria are selected... After all, they are based on literature and interviews and I should point that out better...}

\begin{itemize}
    \item \textbf{Portability} describes the ability to reuse certain assets of a project when migrating to another platform.
    \begin{itemize}
        \item \textbf{Toolset reuse} describes the reuse of development platforms like IDE's, operating systems, etc.
        \item \textbf{Code reuse} expresses the amount of code that can be reused across platforms
        \item \textbf{Platform support} describes the number of platforms that are supported by the cross-platform tool. For this criterion, only platforms other than Android and iOS are relevant as support for Android and iOS is a selection criterion.
    \end{itemize}
    \item \textbf{Application Experience} describes the experience of the finished product: integration with the device, user interface and performance.
    \begin{itemize}
        \item \textbf{Native Integration} describes the integration with native services.
        \begin{itemize}
            \item \textbf{Access to hardware} describes the quality and extensiveness of device APIs. 
            \item \textbf{Platform-specific services} describes integration with platform-specific services like for instance Passbook\footnote{Passbook is an iOS application to gather electronic tickets in one place.}.
        \end{itemize}
        \item \textbf{UI capabilities} describes the ability to create a rich user interface.
        \begin{itemize}
            \item \textbf{Native Look \& Feel} describes whether native user interface elements can be used.  
            \item \textbf{UI element capabilities} describes the capabilities of user interface elements.
        \end{itemize}
        \item \textbf{Performance} describes the overall performance of the application, like the snappiness of the user interface.
    \end{itemize}
    \item \textbf{Productivity} is a measure for the ease of development.
    \begin{itemize}
        \item \textbf{Skill reuse} describes the ability to reuse existing skills.
        \item \textbf{Tooling} describes the quality of the development environment.
        \item \textbf{Testing} describes the quality of software testing tools.
    \end{itemize}
\end{itemize}

\section{Evaluate selected alternatives}

In this stage, the actual evaluation of the selected tools takes place. The evaluation is based on the AHP method, described in section \ref{sec:ahp}. Therefore, all alternatives are compared in pairs with respect to the criteria recorded in the previous stage. In order to gain the experience that is needed to formulate accurate judgements, every tool is used to create a proof of concept application, or parts thereof.

The proof of concept application is described in section \ref{sec:poc}, the evaluation method is described in section \ref{sec:evaluation-method}. The actual evaluation of the tools is described in chapter \ref{chap:evaluation}.

\subsection{Proof-of-Concept application}
\label{sec:poc}

The proof-of-concept application is a rather small but typical enterprise application. It is not typical in the sense that it ``looks'' like the average application. Instead, it is rather typical in the sense that is contains the most requested features. This helps to ensure that the selected tools are thoroughly tested with regard to these essential features. This section describes these features in detail. The requirements documentation is available in Appendix \ref{app:poc}.

\subsubsection{Context \& scenario}

Employees of certain companies occasionally have to make costs for which they would like to be reimbursed. The process for this reimbursement typically involves keeping books, filling out forms and a lot of waiting while a superior deals with the request. Needless to say, there is a great potential for a mobile application here.

The application is designed to do just that. Employees can group a number of invoices into one request, provide evidence for the costs in the form of pictures, sign the document on a phone or tablet and send it to the backend. From there, the request is forwarded to a qualified person that will review the request and deal with it. 

\subsubsection{Typical functional elements}

The proof-of-concept application includes a number of features that are typically required in any application.

\begin{itemize}
    \item \textbf{UI elements} Most applications are useless without a user interface. This application incorporates a number of frequently used UI elements.
    \begin{itemize}
        \item \textbf{Form elements} Virtually all input is captured with ``forms''. The form elements should support read-write and read-only mode. This application uses different types of form elements to represent different kinds of data. 
        \begin{itemize}
            \item \textbf{Text} For inputting arbitrary text.
            \item \textbf{Number} For inputting numbers.
            \item \textbf{Email} For inputting email addresses.
            \item \textbf{Password} For inputting passwords, the content of the input field not shown as characters but as symbols. 
            \item \textbf{Drop-down} For selecting an item from a list.
            \item \textbf{Radio button} Also for selecting an item from a list.
            \item \textbf{Toggle switch} To toggle a state on a property, e.g. an on/off switch.
        \end{itemize}
        \item \textbf{Button} Used to trigger some action.
        \item \textbf{Tab bar} Used to switch between contexts.
        \item \textbf{Activity indicator} A spinning wheel that is displayed when the user is needs to wait for a while because the applications is handling some request.
    \end{itemize}
    \item \textbf{UI modes} The application must support multiple screen modes.
    \begin{itemize}
        \item \textbf{Tablet UI} The display mode used on tablets. The layout typically consists of a narrow column on the left and a wide column on the right (also known as the master--detail interface).
        \item \textbf{Phone UI} The display mode used on smartphones. Nearly the same layout but shows less detail master and detail views are decoupled in separate views.
    \end{itemize}
    \item \textbf{Serialization} In order to communicate with the backend,  data must be serialized using various formats. This application makes use of XML, JSON and plaintext.
    \item \textbf{Input validation} To make sure that the data that is entered is consistent and valid, some validation needs to be done on the device (and on the server).
    \begin{itemize}
        \item \textbf{Data type validation} If a field only accepts numbers, it should automatically make clear to the user that other input than numbers is invalid.
        \item \textbf{Custom validation} There might be some restrictions on some fields that are dependent on other selections in a form. For this kind of consistency checks, custom validation is essential.
    \end{itemize}
    \item \textbf{Sorting} Data-driven apps display a lot of data. It is easier for the end user if the data can be sorted in the right way. 
    \item \textbf{Offline mode} The application should still work when the device is offline.
    \item \textbf{Local Storage} The application needs to be able to store some data that is either persistent or cached.
    \item \textbf{Session management} Business applications are typically bound to a user account. Hence, session management on the client side is also required.
\end{itemize}

Most of these commonly requested features can be built on top of other features but that requires extra work. A tool is more interesting if it includes this functionality out of the box. Part of the evaluation is to investigate the ability to use these functions.

\subsection{Evaluation methodology}
\label{sec:evaluation-method}

The Analytic Hierarchy Process is used to evaluate the alternatives. First, a weight is assigned to every criterion. This weight is the normalized principal right eigenvector\footnote{In AHP, the length of a vector $\vec{v}$ is given by the sum of its entries, not by the Euclidian distance between $\vec{0}$ and $\vec{v}$.} of the pairwise comparison matrix containing the criteria in a single category. The weight of each criterion is multiplied by the weight of its parent. 

Second, a weight is assigned to every combination of alternatives and criteria. All alternatives are compared in pairs with respect to a single criterion and the results are combined in a pairwise comparison of which the principal right eigenvector can be calculated. Again, the weights are given by the normalized eigenvector.

Last, the total weight of every alternative is calculated to obtain a ranking of the alternatives. In case of $n$ alternatives and $m$ criteria, the total weight of an alternative $A_j$ is calculated as
\begin{gather}
    a_j = \sum_{i = 0}^{m} c_i w_i \quad j = 1, \ldots, n
\end{gather}
where $c_i$ is the weight of the criterion $C_i$ and $w_i$ is the weight of alternative $A_j$ with respect to criterion $C_i$. The alternative with the highest weight is ``the winner''. However, the winning alternative may have the most benefits but it could also carry the highest costs. To make sure that the costs are justified, an additional cost-benefit analysis is performed.

Because this is the most important part of this thesis and to long to fit in here, the evaluation is discussed in detail in chapter \ref{chap:evaluation}.

\section{Select the most suitable alternative}

The final step of the software selection process is the selection itself. The decision maker chooses the best-suited alternative based on the results from the evaluation. Since the goal of this thesis is to find the best alternative for cross-platform development, this step is discussed in the conclusion (see chapter \ref{chap:conclusion}).